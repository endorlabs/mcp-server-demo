#!/bin/bash

# Malware Audit Hook for Cursor Agent
# Audits dependency manifest files for malware using Endor Labs scanning

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Add /opt/homebrew/bin/ to the PATH
export PATH="/opt/homebrew/bin:$PATH"

# Function to log messages
log() {
    echo -e "${1}" >&2
}

# Function to check if file is a dependency manifest
is_dependency_file() {
    local file_path="$1"
    case "$file_path" in
        */package.json|*/package-lock.json|*/yarn.lock|*/pnpm-lock.yaml|*/requirements.txt|*/Pipfile|*/Pipfile.lock|*/pyproject.toml|*/poetry.lock|*/go.mod|*/go.sum|*/Cargo.toml|*/Cargo.lock|*/pom.xml|*/build.gradle|*/build.gradle.kts|*/gradle.lockfile|*/composer.json|*/composer.lock|package.json|package-lock.json|yarn.lock|pnpm-lock.yaml|requirements.txt|Pipfile|Pipfile.lock|pyproject.toml|poetry.lock|go.mod|go.sum|Cargo.toml|Cargo.lock|pom.xml|build.gradle|build.gradle.kts|gradle.lockfile|composer.json|composer.lock)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to extract dependencies from manifest file
extract_dependencies() {
    local file_path="$1"
    local file_content="$2"
    
    case "$file_path" in
        */package.json|package.json)
            echo "$file_content" | jq -r '.dependencies // {} | to_entries[] | "npm://\(.key)@\(.value)"' 2>/dev/null || true
            echo "$file_content" | jq -r '.devDependencies // {} | to_entries[] | "npm://\(.key)@\(.value)"' 2>/dev/null || true
            ;;
        */requirements.txt|requirements.txt)
            echo "$file_content" | grep -E '^[a-zA-Z0-9_-]+' | sed 's/==/@/g' | sed 's/^/pypi:\/\//' 2>/dev/null || true
            ;;
        */go.mod|go.mod)
            echo "$file_content" | grep -E '^\s+[a-zA-Z0-9._/-]+' | awk '{print "go://" $1 "@" $2}' 2>/dev/null || true
            ;;
        */Cargo.toml|Cargo.toml)
            echo "$file_content" | grep -E '^\s*[a-zA-Z0-9_-]+.*=' | sed 's/.*"\([^"]*\)".*/cargo:\/\/\1/' 2>/dev/null || true
            ;;
        */pom.xml|pom.xml)
            echo "$file_content" | grep -E '<dependency>' -A 10 | grep -E '<groupId>|<artifactId>|<version>' | sed 's/.*<groupId>\([^<]*\)<\/groupId>.*/\1/' | sed 's/.*<artifactId>\([^<]*\)<\/artifactId>.*/\1/' | sed 's/.*<version>\([^<]*\)<\/version>.*/\1/' | paste -sd ':' | sed 's/^/mvn:\/\//' 2>/dev/null || true
            ;;
        */composer.json|composer.json)
            echo "$file_content" | jq -r '.require // {} | to_entries[] | "packagist:\/\/\(.key)@\(.value)"' 2>/dev/null || true
            ;;
    esac
}

# Function to check dependencies for malware using Endor Labs
check_dependencies_for_malware() {
    local dependencies=("$@")
    local malware_found=false
    
    if [[ ${#dependencies[@]} -eq 0 ]]; then
        log "${GREEN}Malware audit: 0 findings (0 deps changed)${NC}"
        return 0
    fi
    
    log "${YELLOW}Scanning ${#dependencies[@]} dependencies for malware using Endor Labs...${NC}"
    
    # Check if endorctl is available
    if ! command -v endorctl &> /dev/null; then
        log "${YELLOW}Warning: endorctl not found. Skipping malware scan.${NC}"
        log "${YELLOW}Please install endorctl to enable malware detection.${NC}"
        return 0
    fi

    #export ENDOR_API="https://api.endorlabs.com"
    #export ENDOR_TOKEN=""
    
    # Prepare dependency list for Endor Labs API
    local dep_list=""
    for dep in "${dependencies[@]}"; do
        if [[ -n "$dep" && "$dep" != "null" ]]; then
            if [[ -n "$dep_list" ]]; then
                dep_list="$dep_list,\"$dep\""
            else
                dep_list="\"$dep\""
            fi
        fi
    done
    
    if [[ -z "$dep_list" ]]; then
        log "${GREEN}Malware audit: 0 findings (0 deps scanned)${NC}"
        return 0
    fi
    
    # Call Endor Labs API
    local api_response
    local api_exit_code=0
    
    api_response=$(~/Documents/endorctl api create -r QueryMalware -n oss -d "{\"spec\":{\"package_version_names\":{\"names\":[$dep_list]}}}" 2>/dev/null) || api_exit_code=$?
    if [[ $api_exit_code -ne 0 ]]; then
        log "${YELLOW}Warning: Endor Labs API call failed with exit code $api_exit_code. Allowing edit to continue.${NC}"
        return 0
    fi
    
    # Parse the API response
    local malware_detected=false
    
    # Check each dependency in the response
    for dep in "${dependencies[@]}"; do
        if [[ -z "$dep" || "$dep" == "null" ]]; then
            continue
        fi
        
        # Extract package info from dependency string
        local package_name=$(echo "$dep" | sed 's/.*:\/\/\([^@]*\).*/\1/')
        local package_version=$(echo "$dep" | sed 's/.*@\(.*\)/\1/')
        local ecosystem=$(echo "$dep" | sed 's/\([^:]*\):.*/\1/')
        
        # Check if this dependency has malware in the response
        local dep_status=$(echo "$api_response" | jq -r ".responses.values.\"$dep\".list.objects[0].spec.status // \"NOT_FOUND\"" 2>/dev/null)
        
        if [[ "$dep_status" == "MALWARE" ]]; then
            malware_detected=true
            local summary=$(echo "$api_response" | jq -r ".responses.values.\"$dep\".list.objects[0].spec.summary // \"Malware detected\"" 2>/dev/null)
            local reasons=$(echo "$api_response" | jq -r ".responses.values.\"$dep\".list.objects[0].spec.reasons[]?" 2>/dev/null | head -3)
            
            log "${RED}ðŸš¨ MALWARE DETECTED: $dep${NC}"
            log "${RED}  â€¢ Package: $package_name@$package_version${NC}"
            log "${RED}  â€¢ Status: MALWARE${NC}"
            log "${RED}  â€¢ Summary: $summary${NC}"
            
            if [[ -n "$reasons" ]]; then
                log "${RED}  â€¢ Reasons:${NC}"
                echo "$reasons" | while read -r reason; do
                    if [[ -n "$reason" ]]; then
                        log "${RED}    - $reason${NC}"
                    fi
                done
            fi
        fi
    done
    
    if [[ "$malware_detected" == "true" ]]; then
        log "${RED}âŒ BLOCKING: Malware detected in dependencies. Edit operation cancelled.${NC}"
        return 1
    else
        log "${GREEN}Malware audit: 0 findings (${#dependencies[@]} deps scanned)${NC}"
        log "${YELLOW}Scanned dependencies:${NC}"
        for dep in "${dependencies[@]}"; do
            if [[ -n "$dep" && "$dep" != "null" ]]; then
                log "  â€¢ $dep"
            fi
        done
        return 0
    fi
}

# Main execution
main() {
    # Read JSON input from stdin
    local json_input
    json_input=$(cat)
    
    if [[ -z "$json_input" ]]; then
        log "${YELLOW}Warning: No input provided. Skipping malware audit.${NC}"
        exit 0
    fi
    
    # Parse JSON to extract file_path and edits
    local file_path
    local file_content
    
    file_path=$(echo "$json_input" | jq -r '.file_path // empty' 2>/dev/null)
    
    # Extract new_string values from edits array and concatenate them
    file_content=$(echo "$json_input" | jq -r '.edits[]?.new_string // empty' 2>/dev/null | tr -d '\0')
    
    if [[ -z "$file_path" ]]; then
        log "${YELLOW}Warning: No file path in JSON input. Skipping malware audit.${NC}"
        exit 0
    fi
    
    # Check if this is a dependency file
    if ! is_dependency_file "$file_path"; then
        log "${GREEN}Malware audit: Skipping non-dependency file${NC}"
        exit 0
    fi
    
    if [[ -z "$file_content" ]]; then
        log "${YELLOW}Warning: Empty file content. Skipping malware audit.${NC}"
        exit 0
    fi
    
    # Extract dependencies
    local dependencies=()
    while IFS= read -r dep; do
        dependencies+=("$dep")
    done < <(extract_dependencies "$file_path" "$file_content")
    
    # Check for malware
    if check_dependencies_for_malware "${dependencies[@]}"; then
        exit 0
    else
        exit 1
    fi
}

# Check if jq is available (needed for JSON parsing)
if ! command -v jq &> /dev/null; then
    log "${RED}Error: jq is required but not installed. Please install jq to use this hook.${NC}"
    exit 1
fi

# Run main function
main "$@"
