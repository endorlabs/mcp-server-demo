#!/bin/bash

# Malware Audit Hook for Cursor Agent
# Audits dependency manifest files for malware using Endor Labs scanning

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Add /opt/homebrew/bin/ to the PATH
export PATH="/opt/homebrew/bin:$PATH"

# Function to log messages
log() {
    echo -e "${1}" >&2
}


# Function to check dependencies for malware using Endor Labs
check_package_for_malware() {
    local package_name="$1"
    local package_version="$2"
    
    log "${YELLOW}Scanning $package_name@$package_version for malware using Endor Labs...${NC}"
    
    # Check if endorctl is available
    if ! command -v endorctl &> /dev/null; then
        log "${YELLOW}Warning: endorctl not found. Skipping malware scan.${NC}"
        log "${YELLOW}Please install endorctl to enable malware detection.${NC}"
        return 0
    fi

    # log the path for endorctl
    log "${YELLOW}Endor Labs path: $(which endorctl)${NC}"

    # read ENDOR_API and ENDOR_TOKEN from the /tmp/.env file
    export ENDOR_API=$(grep ENDOR_API /tmp/.env | cut -d '=' -f 2)
    export ENDOR_TOKEN=$(grep ENDOR_TOKEN /tmp/.env | cut -d '=' -f 2)
   
    # Prepare dependency list for Endor Labs API, everything is prefixed with npm://
    local dep_list="\"npm://$package_name@$package_version\""
    local dep_name="npm://$package_name@$package_version"
    
    # Call Endor Labs API
    local api_response
    local api_exit_code=0
    
    api_response=$(endorctl api create -r QueryMalware -n oss -d "{\"spec\":{\"package_version_names\":{\"names\":[$dep_list]}}}" 2>/tmp/endorctl.log) || api_exit_code=$?
    if [[ $api_exit_code -ne 0 ]]; then
        log "${YELLOW}Warning: Endor Labs API call failed with exit code $api_exit_code. Allowing edit to continue.${NC}"
        return 0
    fi
    
    # Parse the API response
    local malware_detected=false

    rm -f /tmp/malware_detected_packages.txt 

    log "${YELLOW}Endor Labs API response: $api_response${NC}"
    
    # Check the dependency in the response
    local dep_status=$(echo "$api_response" | jq -r ".responses.values.\"$dep_name\".list.objects[0].spec.status // \"NOT_FOUND\"" 2>/dev/null)
        
    if [[ "$dep_status" == "MALWARE" ]]; then
        malware_detected=true
        local summary=$(echo "$api_response" | jq -r ".responses.values.\"$dep_name\".list.objects[0].spec.summary // \"Malware detected\"" 2>/dev/null)
        local reasons=$(echo "$api_response" | jq -r ".responses.values.\"$dep_name\".list.objects[0].spec.reasons[]?" 2>/dev/null | head -3)
        
        log "${RED}üö® MALWARE DETECTED: $dep_name${NC}"
        log "${RED}  ‚Ä¢ Package: $package_name@$package_version${NC}"
        log "${RED}  ‚Ä¢ Status: MALWARE${NC}"
        log "${RED}  ‚Ä¢ Summary: $summary${NC}"

        # write the name of the package and the version to a file
        #echo "$package_name@$package_version" >> /tmp/malware_detected_packages.txt
        
        if [[ -n "$reasons" ]]; then
            log "${RED}  ‚Ä¢ Reasons:${NC}"
            echo "$reasons" | while read -r reason; do
                if [[ -n "$reason" ]]; then
                    log "${RED}    - $reason${NC}"
                fi
            done
        fi
    fi
    
    if [[ "$malware_detected" == "true" ]]; then
        log "${RED}‚ùå BLOCKING: Malware detected in command. Command blocked.${NC}"
        # return a block according to this format 
        cat << EOF
{
  "permission": "deny",
  "user_message": "Malware detected in command. Command blocked. $package_name@$package_version",
  "agent_message": "Malware detected in command. Command blocked. $package_name@$package_version"
}
EOF
        return 1
    else
        log "${GREEN}Malware audit: 0 findings. No malware detected.${NC}"
        cat << EOF
{
  "permission": "allow",
  "user_message": "Malware audit: 0 findings. No malware detected.",
  "agent_message": "Malware audit: 0 findings. No malware detected."
}
EOF
        return 0
    fi
}

# Main execution
main() {
    # Read JSON input from stdin
    local json_input
    json_input=$(cat)
    
    if [[ -z "$json_input" ]]; then
        log "${YELLOW}Warning: No input provided. Skipping malware audit.${NC}"
        exit 0
    fi
    
    # Parse JSON to extract command
    local command
    command=$(echo "$json_input" | jq -r '.command // empty' 2>/dev/null)

    log "${YELLOW}Command: $command${NC}"
    
    # Check if this command attempts to install an npm package, look for npm install <package_name>@<package_version> anywhere in the command 
    if ! [[ "$command" =~ npm\ install\ .* ]]; then
        log "${GREEN}Malware audit: Skipping non-npm install command${NC}"
        exit 0
    fi
    
    # if this is an npm install command, extract the package name and version from the command, it looks like this: npm install <package_name>@<package_version>
    local package_name=$(echo "$command" | sed 's/.*npm install \([^@]*\)@.*/\1/')
    local package_version=$(echo "$command" | sed 's/.*npm install [^@]*@\(.*\)/\1/')
    
    # Check for malware
    check_package_for_malware "$package_name" "$package_version"
}

# Check if jq is available (needed for JSON parsing)
if ! command -v jq &> /dev/null; then
    log "${RED}Error: jq is required but not installed. Please install jq to use this hook.${NC}"
    exit 1
fi

# Run main function
main "$@"
